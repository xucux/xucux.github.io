{"meta":{"title":"Xucux's Blog","subtitle":"Xucux的技术分享博客","description":"一个记录编程知识的小站！","author":"xucux","url":"https://xucux.github.io","root":"/"},"pages":[{"title":"","date":"2023-01-30T09:29:13.990Z","updated":"2023-01-30T09:29:13.990Z","comments":true,"path":"404.html","permalink":"https://xucux.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-01-30T09:29:13.990Z","updated":"2023-01-30T09:29:13.990Z","comments":true,"path":"about/index.html","permalink":"https://xucux.github.io/about/index.html","excerpt":"","text":"IT民工，努力搬砖中……"},{"title":"所有分类","date":"2023-01-30T09:29:13.990Z","updated":"2023-01-30T09:29:13.990Z","comments":true,"path":"categories/index.html","permalink":"https://xucux.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-01-30T09:29:13.990Z","updated":"2023-01-30T09:29:13.990Z","comments":true,"path":"friends/index.html","permalink":"https://xucux.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。","author":"xucux"},{"title":"","date":"2023-01-30T09:29:13.990Z","updated":"2023-01-30T09:29:13.990Z","comments":true,"path":"list/index.html","permalink":"https://xucux.github.io/list/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-01-30T09:29:13.994Z","updated":"2023-01-30T09:29:13.994Z","comments":true,"path":"tags/index.html","permalink":"https://xucux.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-21T01:55:57.000Z","updated":"2023-01-30T09:29:13.990Z","comments":true,"path":"more/catchCat/index.html","permalink":"https://xucux.github.io/more/catchCat/index.html","excerpt":"","text":"游戏规则 点击小圆点，围住小猫。 你点击一次，小猫走一次。 直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。"},{"title":"","date":"2022-09-22T01:55:57.000Z","updated":"2023-01-30T09:29:13.990Z","comments":false,"path":"page/bookmarks/index.html","permalink":"https://xucux.github.io/page/bookmarks/index.html","excerpt":"","text":"🔖收藏的书签🔖","author":"xucux"},{"title":"","date":"2022-09-22T01:55:57.000Z","updated":"2023-01-30T09:29:13.990Z","comments":true,"path":"page/messages/index.html","permalink":"https://xucux.github.io/page/messages/index.html","excerpt":"","text":"📝留言板 🍨欢迎你的来访，请遵守相关法律法规，🚯文明灌水，谢谢合作~","author":"xucux"}],"posts":[{"title":"SpringBoot集成企业微信群机器人（运维报警）","slug":"SpringBoot集成企业微信群机器人（运维报警）","date":"2023-01-29T09:40:50.000Z","updated":"2023-01-30T09:29:13.990Z","comments":true,"path":"post/SpringBoot集成企业微信群机器人（运维报警）/","link":"","permalink":"https://xucux.github.io/post/SpringBoot%E9%9B%86%E6%88%90%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88%E8%BF%90%E7%BB%B4%E6%8A%A5%E8%AD%A6%EF%BC%89/","excerpt":"之前有集成过钉钉群机器人🤖报警，这次主要是SpringBoot集成企业微信群机器人报警，主要使用两种方式调用企业微信的HttpApi，一种为Forest，一种为RestTemplate","text":"之前有集成过钉钉群机器人🤖报警，这次主要是SpringBoot集成企业微信群机器人报警，主要使用两种方式调用企业微信的HttpApi，一种为Forest，一种为RestTemplate 相关文档： 企业微信群机器人配置说明 1.配置参数12345678910111213141516171819202122import lombok.Getter;import lombok.Setter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.List;/** * @descriptions: 配置参数 * @author: xucux */@Component@Getter@Setter@ConfigurationProperties(prefix = &quot;notice&quot;)public class NoticeProperties &#123; private String wechatKey; private List&lt;String&gt; phoneList;&#125; 这个key的获取方式：群机器人配置说明 yaml文件配置数据： 12345notice: ####### 企业微信群机器人key wechat-key: xxxxxxxxx-xxx-xxx-xxxx-xxxxxxxxxx ####### 需要@的群成员手机号 phone-list: 2.Forest的Http客户端配置使用Forest这里用的Forest ，感觉还挺强大灵活 官方文档，如果你喜欢使用httpClient或者okHttp建议你看看forest ；如果你更喜欢RestTemplate，那就使用RestTemplate。 POM依赖123456&lt;!-- 轻量级HTTP客户端框架 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.dtflys.forest&lt;/groupId&gt; &lt;artifactId&gt;forest-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.28&lt;/version&gt;&lt;/dependency&gt; yaml文件配置日志打开关闭请参考自己的业务需要 123456789101112131415161718192021222324## 轻量级HTTP客户端框架forestforest: # 配置底层API为 okhttp3 backend: okhttp3 # 连接池最大连接数，默认值为500 max-connections: 1000 # 每个路由的最大连接数，默认值为500 max-route-connections: 500 # 请求超时时间，单位为毫秒, 默认值为3000 timeout: 3000 # 连接超时时间，单位为毫秒, 默认值为2000 connect-timeout: 3000 # 请求失败后重试次数，默认为0次不重试 retry-count: 1 # 单向验证的HTTPS的默认SSL协议，默认为SSLv3 ssl-protocol: SSLv3 # 打开或关闭日志，默认为true logEnabled: true # 打开/关闭Forest请求日志（默认为 true） log-request: true # 打开/关闭Forest响应状态日志（默认为 true） log-response-status: true # 打开/关闭Forest响应内容日志（默认为 false） log-response-content: true 发送请求1234567891011121314151617181920public interface NoticeClient &#123; /** * 企业微信机器人 发送 https 请求 * * @param keyValue * @return */ @Post( url = &quot;https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=&#123;keyValue&#125;&quot;, headers = &#123; &quot;Accept-Charset: utf-8&quot;, &quot;Content-Type: application/json&quot; &#125;, dataType = &quot;json&quot; ) ForestResponse&lt;JsonObject&gt; weChatNotice(@Var(&quot;keyValue&quot;) String keyValue, @JSONBody Map&lt;String, Object&gt; body );&#125; 3.定义服务3.1 接口1234567891011121314151617181920212223242526/** * @descriptions: 消息通知接口 * @author: xucux */public interface NoticeService &#123; /** * 发送错误信息至群机器人 * @param throwable * @param msg */ void sendError(Throwable throwable,String msg); /** * 发送文本信息至群机器人 * @param msg */ void sendByMd(String msg); /** * 发送md至群机器人 * @param msg 文本消息 * @param isAtALL 是否@所有人 true是 false否 */ void sendByText(String msg,boolean isAtALL);&#125; 3.2 服务实现注意：这里的包名（com.github）填自己项目内的包名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163import com.dtflys.forest.http.ForestResponse;import com.google.gson.JsonObject;import lombok.extern.slf4j.Slf4j;import org.apache.commons.collections4.CollectionUtils;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import java.util.stream.Collectors;/** * @descriptions: 通知实现 * @author: xucux */@Service@Slf4jpublic class NoticeServiceImpl implements NoticeService &#123; @Value(&quot;$&#123;spring.application.name&#125;&quot;) private String appName; @Value(&quot;$&#123;spring.profiles.active&#125;&quot;) private String env; @Autowired private NoticeClient noticeClient; @Autowired private NoticeProperties noticeProperties; /** * 发送错误信息至群机器人 * * @param throwable * @param msg */ @Override public void sendError(Throwable throwable, String msg) &#123; String errorClassName = throwable.getClass().getSimpleName(); if (StringUtils.isBlank(msg))&#123; msg = throwable.getMessage() == null ? &quot;出现null值&quot; : throwable.getMessage(); &#125; ByteArrayOutputStream baos = new ByteArrayOutputStream(); throwable.printStackTrace(new PrintStream(baos)); String bodyStr = StringComUtils.limitStrNone(regexThrowableStr(baos.toString()),450); String md = getMdByTemplate(appName, env, errorClassName, msg, bodyStr); sendByMd(md); &#125; /** * 发送文本信息至群机器人 * * @param msg */ @Override public void sendByMd(String msg) &#123; try &#123; Map&lt;String, Object&gt; params = buildMdParams(msg); ForestResponse&lt;JsonObject&gt; response = noticeClient.weChatNotice(noticeProperties.getWechatKey(), params); log.debug(&quot;WeChatRobo-Send Error:&#123;&#125; Status:&#123;&#125;&quot;,response.isError(),response.getStatusCode()); &#125; catch (Exception e) &#123; log.error(&quot;WeChatRobot-发送文本消息异常 body:&#123;&#125;&quot;,msg,e); &#125; &#125; /** * 发送md至群机器人 * * @param msg */ @Override public void sendByText(String msg,boolean isAtALL) &#123; try &#123; Map&lt;String, Object&gt; params = buildTextParams(msg,noticeProperties.getPhoneList(),isAtALL); ForestResponse&lt;JsonObject&gt; response = noticeClient.weChatNotice(noticeProperties.getWechatKey(), params); log.debug(&quot;WeChatRobo-Send Error:&#123;&#125; Status:&#123;&#125;&quot;,response.isError(),response.getStatusCode()); &#125; catch (Exception e) &#123; log.error(&quot;WeChatRobot-发送文本消息异常 body:&#123;&#125;&quot;,msg,e); &#125; &#125; /** * 构建发送文本消息格式的参数 * @param phoneList @群用户 * @param isAtALL 是否@所有人 * @return */ private Map&lt;String,Object&gt; buildTextParams(String text, List&lt;String&gt; phoneList, boolean isAtALL)&#123; Map&lt;String,Object&gt; params = new HashMap&lt;&gt;(); Map&lt;String,Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;content&quot;,text); if (isAtALL)&#123; phoneList.add(&quot;@all&quot;); &#125; if (CollectionUtils.isNotEmpty(phoneList))&#123; data.put(&quot;mentioned_mobile_list&quot;, phoneList); &#125; params.put(&quot;msgtype&quot;,&quot;text&quot;); params.put(&quot;text&quot;,data); return params; &#125; /** * 构建发送markdown消息格式的参数 * * @param md * @return */ private Map&lt;String,Object&gt; buildMdParams(String md)&#123; Map&lt;String,Object&gt; params = new HashMap&lt;&gt;(); Map&lt;String,Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;content&quot;,md); params.put(&quot;msgtype&quot;,&quot;markdown&quot;); params.put(&quot;markdown&quot;,data); return params; &#125; private String regexThrowableStr(String str)&#123; try &#123; // 注意：这里的包名（com.github）填自己项目内的包名 String pattern = &quot;(com)(\\\\.)(github)(.&#123;10,200&#125;)(\\\\))&quot;; Pattern r = Pattern.compile(pattern); Matcher m=r.matcher(str); List&lt;String&gt; list = new ArrayList&lt;&gt;(); while (m.find()) &#123; list.add(m.group()); &#125; if (CollectionUtils.isEmpty(list))&#123; return str; &#125; String s = list.stream().collect(Collectors.joining(&quot;\\n&quot;)); return s; &#125; catch (Exception e) &#123; return str; &#125; &#125; private String getMdByTemplate(String appName,String env,String errorClassName,String msg,String bodyStr)&#123; String titleTpl = &quot;### 异常告警通知\\n#### 应用：%s\\n#### 环境：&lt;font color=\\&quot;info\\&quot;&gt;%s&lt;/font&gt;\\n##### 异常：&lt;font color=\\&quot;warning\\&quot;&gt;%s&lt;/font&gt;\\n&quot;; String bodyTpl = &quot;\\nMsg：%s\\nDetail：\\n&gt;%s&quot;; String footerTpl = &quot;\\n&lt;font color=\\&quot;comment\\&quot;&gt;%s&lt;/font&gt;&quot;; String title = String.format(titleTpl, appName, env, errorClassName); String body = String.format(bodyTpl, msg,bodyStr); String dateStr = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH:mm:ss&quot;)); String footer = String.format(footerTpl, dateStr); return title.concat(body).concat(footer); &#125;&#125; 使用到的工具方法： 123456789101112131415161718/** * 限制文本描述 * * @param content 内容或问题 * @param charNumber 长度 * @return */public static String limitStrNone(String content ,int charNumber)&#123; if (StringUtils.isNotBlank(content))&#123; if (content.length() &gt; charNumber)&#123; String substring = content.substring(0, charNumber); return substring; &#125;else &#123; return content; &#125; &#125; return &quot;&quot;;&#125; 4.群接收消息的效果 5.使用RestTemplate发送请求时配置RestTemplate12345678910111213141516171819202122232425262728293031323334353637import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.http.client.ClientHttpRequestFactory;import org.springframework.http.client.SimpleClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;import java.util.Collections;/** * @descriptions: RestTemplate配置 * @author: xucux */@Configurationpublic class RestTemplateConfig &#123; @Bean public RestTemplate restTemplate(ClientHttpRequestFactory factory,)&#123; RestTemplate restTemplate = new RestTemplate(factory); //restTemplate.setInterceptors(Collections.singletonList(restLogInterceptor)); // 这里可以注入自定义拦截器 return restTemplate; &#125; @Bean public ClientHttpRequestFactory simpleClientHttpRequestFactory()&#123; SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); // 单位为ms factory.setReadTimeout(10000); // 单位为ms factory.setConnectTimeout(10000); return factory; &#125;&#125; 重新在写一个NoticeClient，其中还有一个方法是介绍RestTemplate如何发送文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import com.alibaba.fastjson.JSONObject;import com.sztb.component.exception.BaseAssert;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.io.InputStreamResource;import org.springframework.core.io.Resource;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.util.LinkedMultiValueMap;import org.springframework.util.MultiValueMap;import org.springframework.web.client.RestTemplate;import java.io.IOException;import java.io.InputStream;import java.util.Map;/** * @descriptions: 发送给企业微信机器人 * @author: xucux * * https://work.weixin.qq.com/api/doc/90000/90136/91770 */public class NoticeClient &#123; @Autowired private RestTemplate restTemplate; public static final String SEND_MESSAGE_URL = &quot;https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=&#123;weChatKey&#125;&quot;; public static final String UPLOAD_FILE_URL = &quot;https://qyapi.weixin.qq.com/cgi-bin/webhook/upload_media?key=&#123;weChatKey&#125;&amp;type=file&quot;; public ResponseEntity&lt;JSONObject&gt; weChatNotice(String weChatKey, Map&lt;String, Object&gt; body )&#123; BaseAssert.verify(StringUtils.isBlank(weChatKey),&quot;消息推送给机器人失败，未配置：weChatKey&quot;); ResponseEntity&lt;JSONObject&gt; response = restTemplate.postForEntity(SEND_MESSAGE_URL, body, JSONObject.class,weChatKey); return response; &#125; public ResponseEntity&lt;JSONObject&gt; uploadMedia(String weChatKey, String fileName, InputStream inputStream)&#123; BaseAssert.verify(StringUtils.isAnyBlank(weChatKey,fileName),&quot;文件推送企业微信失败，未配置：weChatKey，fileName&quot;); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); MultiValueMap&lt;String, Object&gt; body = new LinkedMultiValueMap&lt;&gt;(); // 新建流资源，必须重写contentLength()和getFilename() Resource resource = new InputStreamResource(inputStream)&#123; //文件长度,单位字节 @Override public long contentLength() throws IOException &#123; long size = inputStream.available(); return size; &#125; //文件名 @Override public String getFilename()&#123; return fileName; &#125; &#125;; body.add(&quot;media&quot;,resource); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity(body, headers); ResponseEntity&lt;JSONObject&gt; response = restTemplate.postForEntity(UPLOAD_FILE_URL, entity, JSONObject.class,weChatKey); return response; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/tags/Java/"},{"name":"企业微信","slug":"企业微信","permalink":"https://xucux.github.io/tags/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xucux.github.io/tags/SpringBoot/"},{"name":"报警","slug":"报警","permalink":"https://xucux.github.io/tags/%E6%8A%A5%E8%AD%A6/"}],"author":"xucux"},{"title":"Maven的setting配置属性解析","slug":"Maven的setting配置属性解析","date":"2023-01-29T09:33:05.000Z","updated":"2023-01-30T09:29:13.990Z","comments":true,"path":"post/Maven的setting配置属性解析/","link":"","permalink":"https://xucux.github.io/post/Maven%E7%9A%84setting%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90/","excerpt":"Maven的setting.xml文件解析","text":"Maven的setting.xml文件解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;!--本地仓库。该值表示构建系统本地仓库的路径。其默认值为$&#123;user.home&#125;/.m2/repository。 --&gt; &lt;localRepository&gt;$&#123;user.home&#125;/.m2/repository &lt;/localRepository&gt; &lt;!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。 --&gt; &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; &lt;!--Maven是否需要使用plugin-registry.xml文件来管理插件版本。 --&gt; &lt;!--如果设置为true，则在&#123;user.home&#125;/.m2下需要有一个plugin-registry.xml来对plugin的版本进行管理 --&gt; &lt;!--默认为false。 --&gt; &lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt; &lt;!--表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。 --&gt; &lt;!--当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。 --&gt; &lt;offline&gt;false&lt;/offline&gt; &lt;!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。 --&gt; &lt;!--该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。 --&gt; &lt;!--当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。 --&gt; &lt;!--默认情况下该列表包含了org.apache.maven.plugins。 --&gt; &lt;pluginGroups&gt; &lt;!--plugin的组织Id（groupId） --&gt; &lt;pluginGroup&gt;org.codehaus.mojo&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;!--用来配置不同的代理，多代理profiles可以应对笔记本或移动设备的工作环境：通过简单的设置profile id就可以很容易的更换整个代理配置。 --&gt; &lt;proxies&gt; &lt;!--代理元素包含配置代理时需要的信息 --&gt; &lt;proxy&gt; &lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt; &lt;id&gt;myproxy&lt;/id&gt; &lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt; &lt;active&gt;true&lt;/active&gt; &lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;protocol&gt;http://…&lt;/protocol&gt; &lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;host&gt;proxy.somewhere.com&lt;/host&gt; &lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; &lt;password&gt;somepassword&lt;/password&gt; &lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt; &lt;nonProxyHosts&gt;*.google.com|ibiblio.org&lt;/nonProxyHosts&gt; &lt;/proxy&gt; &lt;/proxies&gt; &lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt; &lt;servers&gt; &lt;!--服务器元素包含配置服务器时需要的信息 --&gt; &lt;server&gt; &lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt; &lt;id&gt;server001&lt;/id&gt; &lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;username&gt;my_login&lt;/username&gt; &lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;password&gt;my_password&lt;/password&gt; &lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是/home/hudson/.ssh/id_dsa）以及如果需要的话，一个密钥 --&gt; &lt;!--将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt; &lt;privateKey&gt;$&#123;usr.home&#125;/.ssh/id_dsa&lt;/privateKey&gt; &lt;!--鉴权时使用的私钥密码。 --&gt; &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt; &lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。--&gt; &lt;!--这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt; &lt;filePermissions&gt;664&lt;/filePermissions&gt; &lt;!--目录被创建时的权限。 --&gt; &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt; &lt;!--传输层额外的配置项 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/server&gt; &lt;/servers&gt; &lt;!--为仓库列表配置的下载镜像列表。 --&gt; &lt;mirrors&gt; &lt;!--给定仓库的下载镜像。 --&gt; &lt;mirror&gt; &lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt; &lt;id&gt;planetmirror.com&lt;/id&gt; &lt;!--镜像名称 --&gt; &lt;name&gt;PlanetMirror Australia&lt;/name&gt; &lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt; &lt;url&gt;http://downloads.planetmirror.com/pub/maven2&lt;/url&gt; &lt;!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo1.maven.org/maven2）的镜像，--&gt; &lt;!--就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。--&gt; &lt;!--它包含了id，activation, repositories, pluginRepositories和 properties元素。--&gt; &lt;!--这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。--&gt; &lt;!--如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 --&gt; &lt;profiles&gt; &lt;!--根据环境参数来调整的构件的配置 --&gt; &lt;profile&gt; &lt;!--该配置的唯一标识符。 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。--&gt; &lt;!--如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。--&gt; &lt;!--activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。--&gt; &lt;!--profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标识 --&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;) --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。--&gt; &lt;!--如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。--&gt; &lt;!--另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--对应profile的扩展属性列表。Maven属性和Ant中的属性一样，可以用来存放一些值。这些值可以在POM中的任何地方使用标记$&#123;X&#125;来使用，这里X是指属性的名称。--&gt; &lt;!--属性有五种不同的形式，并且都能在settings.xml文件中访问。 --&gt; &lt;!--1. env.X: 在一个变量前加上&quot;env.&quot;的前缀，会返回一个shell环境变量。例如,&quot;env.PATH&quot;指代了$path环境变量（在Windows上是%PATH%）。 --&gt; &lt;!--2. project.x：指代了POM中对应的元素值。 --&gt; &lt;!--3. settings.x: 指代了settings.xml中对应元素的值。 --&gt; &lt;!--4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问， --&gt; &lt;!-- 如/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0/jre。 --&gt; &lt;!--5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以$&#123;someVar&#125;的形式使用。 --&gt; &lt;properties&gt; &lt;!-- 如果这个profile被激活，那么属性$&#123;user.install&#125;就可以被访问了 --&gt; &lt;user.install&gt;usr/local/winner/jobs/maven-guide&lt;/user.install&gt; &lt;/properties&gt; &lt;!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--远程仓库唯一标识 --&gt; &lt;id&gt;codehausSnapshots&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;Codehaus Snapshots&lt;/name&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：--&gt; &lt;!--always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做:--&gt; &lt;!--ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。--&gt; &lt;!--例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt; &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。--&gt; &lt;!--Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。--&gt; &lt;!--Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。--&gt; &lt;!--每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。--&gt; &lt;!--任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。--&gt; &lt;!--如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。--&gt; &lt;!--如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;env-test&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/settings&gt;","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xucux.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/tags/Java/"},{"name":"工具","slug":"工具","permalink":"https://xucux.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Maven","slug":"Maven","permalink":"https://xucux.github.io/tags/Maven/"}],"author":"xucux"}],"categories":[{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/categories/Java/"},{"name":"开发工具","slug":"开发工具","permalink":"https://xucux.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/tags/Java/"},{"name":"企业微信","slug":"企业微信","permalink":"https://xucux.github.io/tags/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xucux.github.io/tags/SpringBoot/"},{"name":"报警","slug":"报警","permalink":"https://xucux.github.io/tags/%E6%8A%A5%E8%AD%A6/"},{"name":"工具","slug":"工具","permalink":"https://xucux.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Maven","slug":"Maven","permalink":"https://xucux.github.io/tags/Maven/"}]}