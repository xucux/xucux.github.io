{"meta":{"title":"Xucux's Blog","subtitle":"Xucux的技术分享博客","description":"一个记录编程知识的小站！","author":"xucux","url":"https://xucux.github.io","root":"/"},"pages":[{"title":"","date":"2023-02-02T09:56:25.476Z","updated":"2023-02-02T09:56:25.476Z","comments":true,"path":"404.html","permalink":"https://xucux.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2023-02-02T09:56:25.480Z","updated":"2023-02-02T09:56:25.480Z","comments":true,"path":"about/index.html","permalink":"https://xucux.github.io/about/index.html","excerpt":"","text":"IT民工，努力搬砖中……"},{"title":"所有分类","date":"2023-02-02T09:56:25.480Z","updated":"2023-02-02T09:56:25.480Z","comments":true,"path":"categories/index.html","permalink":"https://xucux.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2023-02-02T09:56:25.480Z","updated":"2023-02-02T09:56:25.480Z","comments":true,"path":"friends/index.html","permalink":"https://xucux.github.io/friends/index.html","excerpt":"博主们只争朝夕，不负韶华Xucux's Blog编程，CV工程","text":"博主们只争朝夕，不负韶华Xucux's Blog编程，CV工程 本站信息友链格式申请须知title: Xucux&#39;s Blog url: https://xucux.github.io/ avatar: https://raw.githubusercontent.com/xucux/assets/main/blog/img/avatar_150x150.jpg screenshot: https://raw.githubusercontent.com/xucux/assets/main/blog/img/screenshot.png description: 编程，CV工程 title: # 名称 avatar: # 头像 url: # 链接 screenshot: # 截图 escription: # 描述 note warning 如何添加 在这个页面的评论区留言就行，看到我就会加上去，我的你也加一下，信息都给了 note info 图片的处理 尽可能将头像和快照压缩到100KB以内,以提高加载速度.以下是avatar和screenshot的推荐尺寸: avatar: 150x150 (宽x高) screenshot: 540x360 (宽x高)","author":"xucux"},{"title":"","date":"2023-02-02T09:56:25.480Z","updated":"2023-02-02T09:56:25.480Z","comments":true,"path":"list/index.html","permalink":"https://xucux.github.io/list/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-02-02T09:56:25.480Z","updated":"2023-02-02T09:56:25.480Z","comments":true,"path":"tags/index.html","permalink":"https://xucux.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-02-02T09:56:25.480Z","updated":"2023-02-02T09:56:25.480Z","comments":true,"path":"more/announcement/index.html","permalink":"https://xucux.github.io/more/announcement/index.html","excerpt":"","text":"测试"},{"title":"","date":"2021-09-21T01:55:57.000Z","updated":"2023-02-02T09:56:25.480Z","comments":true,"path":"more/catchCat/index.html","permalink":"https://xucux.github.io/more/catchCat/index.html","excerpt":"","text":"游戏规则 点击小圆点，围住小猫。 你点击一次，小猫走一次。 直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。"},{"title":"","date":"2023-02-02T09:56:25.480Z","updated":"2023-02-02T09:56:25.480Z","comments":true,"path":"more/timeclock/index.html","permalink":"https://xucux.github.io/more/timeclock/index.html","excerpt":"","text":"测试"},{"title":"","date":"2022-09-22T01:55:57.000Z","updated":"2023-02-02T09:56:25.480Z","comments":false,"path":"page/bookmarks/index.html","permalink":"https://xucux.github.io/page/bookmarks/index.html","excerpt":"","text":"🔖收藏的书签🔖","author":"xucux"},{"title":"","date":"2022-09-22T01:55:57.000Z","updated":"2023-02-02T09:56:25.480Z","comments":true,"path":"page/messages/index.html","permalink":"https://xucux.github.io/page/messages/index.html","excerpt":"","text":"📝留言板 🍨欢迎你的来访，请遵守相关法律法规，🚯文明灌水，谢谢合作~","author":"xucux"}],"posts":[{"title":"使用git branch命令在指定的commit id点创建分支","slug":"使用git-branch命令在指定的commit-id点创建分支","date":"2023-01-31T05:42:30.000Z","updated":"2023-02-02T09:56:25.480Z","comments":true,"path":"post/使用git-branch命令在指定的commit-id点创建分支/","link":"","permalink":"https://xucux.github.io/post/%E4%BD%BF%E7%94%A8git-branch%E5%91%BD%E4%BB%A4%E5%9C%A8%E6%8C%87%E5%AE%9A%E7%9A%84commit-id%E7%82%B9%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF/","excerpt":"","text":"主要是为了将一个提交之前的全部记录，转移到一个新的分支上，其中有两种命令git checkout和git branch，都可以满足我们的需求 查看提交日志查看所有的提交日志 git log \\-g 通过commit信息找到需要恢复的那个commit的id，比如commitId为8bc6cc706f600d96dd3c03b9d69fcc279b10a505 git branch再使用命令创建分支 # git branch &lt;new_branch_name&gt; &lt;commid_id&gt; git branch dev_bak 8bc6cc706f600d96dd3c03b9d69fcc279b10a505 git checkout# 第一种，创建 git checkout -b &lt;new_branch_name&gt; &lt;commid_id&gt; # 第二种 git checkout &lt;commid_id&gt; then git switch -c &lt;new_branch_name&gt;","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xucux.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"开发工具/Git","permalink":"https://xucux.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://xucux.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"Git","permalink":"https://xucux.github.io/tags/Git/"},{"name":"开发环境","slug":"开发环境","permalink":"https://xucux.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"author":"xucux"},{"title":"LocalDate、LocalTime、LocalDateTime的常用API和计算","slug":"LocalDate、LocalTime、LocalDateTime的常用API和计算","date":"2023-01-31T05:29:56.000Z","updated":"2023-02-02T09:56:25.476Z","comments":true,"path":"post/LocalDate、LocalTime、LocalDateTime的常用API和计算/","link":"","permalink":"https://xucux.github.io/post/LocalDate%E3%80%81LocalTime%E3%80%81LocalDateTime%E7%9A%84%E5%B8%B8%E7%94%A8API%E5%92%8C%E8%AE%A1%E7%AE%97/","excerpt":"","text":"从Java 8开始，java.time包提供了新的日期和时间API，主要涉及的类型有： 本地日期和时间：LocalDateTime，LocalDate，LocalTime； 带时区的日期和时间：ZonedDateTime； 时刻：Instant； 时区：ZoneId，ZoneOffset； 时间间隔：Duration。 以及一套新的用于取代SimpleDateFormat的格式化类型DateTimeFormatter。 本文仅仅简述部分接口，详细还请了解官方API文档 一、概述LocalDateTime表示日期和时间 LocalDate用来表示日期 LocalTIme表示时间，大概就是LocalDateTime = LocalDate + LocalTime ZonedDateTime带时区的日期和时间 他们的关系： 常用解析LocalTime.of(int hour,int minute,int second)// 指定时、分、秒，参数不可缺省 LocalDate.of(int year,int mouth,int day)// 指定年、月、日，参数不可缺省，这里指定月份的话是从1开始，与Calendar不同，Calendar的月份是从0开始，这也就是LocalDate比Calendar处理时间要方便的多。 LocalDate.of(int year,MOUTH mouth,int day)// 指定年、月、日 LocalDateTime.of(nt year,int mouth,int day,int hour,int minute,int second,int nanoOfSecond)// 指定年、月、日、时、分、秒、纳秒，参数可缺省 LocalDateTime.of(nt year,MOUTH mouth,int day,int hour,int minute,int second,int nanoOfSecond) LocalDateTime.of(LocalDate localDate,LocalTime localTime)// 指定localDate localTime组合成日期时间 这里我们使用常用构造打印一下： public static void main(String args[] )&#123; // 当前日期和时间 LocalDateTime localDateTime = LocalDateTime.now(); // 转换到当前日期 LocalDate localDate = localDateTime.toLocalDate(); // 转换到当前时间 LocalTime localTime = localDateTime.toLocalTime(); // LocalDate的部分构造 LocalDate localDate1 = LocalDate.now(); LocalDate localDate2 = LocalDate.of(2020, 02, 20); LocalDate localDate3 = LocalDate.parse(&quot;2020-02-20&quot;); LocalDate localDate4 = LocalDate.of(2020, Month.FEBRUARY, 20); // LocalDate的部分构造 LocalTime localTime1 = LocalTime.now(); LocalTime localTime2 = LocalTime.parse(&quot;07:30&quot;); LocalTime localTime3 = LocalTime.of(7, 30); LocalTime localTime4 = LocalTime.of(7, 29, 59, 999000123); // LocalDateTime的部分构造 LocalDateTime localDateTime1 = LocalDateTime.of(localDate1, localTime1); LocalDateTime localDateTime2 = LocalDateTime.now(); LocalDateTime localDateTime3 = LocalDateTime.now(ZoneId.of(&quot;America/Chicago&quot;)); LocalDateTime localDateTime4 = LocalDateTime.parse(&quot;2020-02-20T08:15:59&quot;); // 获取时区 ZoneId romeZone = ZoneId.of(&quot;Europe/Rome&quot;); ZoneId defaultZone = TimeZone.getDefault().toZoneId(); // 获取当前时刻 Instant instant = Instant.now(); // 获取日期和日期时间 LocalDate localDate5 = LocalDate.of(2020, Month.OCTOBER, 31); LocalDateTime localDateTime5 = LocalDateTime.of(2020, Month.OCTOBER, 31, 13, 45); ZonedDateTime zonedDateTime1 = localDate5.atStartOfDay(romeZone); ZonedDateTime zonedDateTime2 = localDateTime5.atZone(romeZone); ZonedDateTime zonedDateTime3 = instant.atZone(romeZone); ZonedDateTime zonedDateTime4 = instant.atZone(defaultZone); &#125; 输出： ======================================= localDate = 2021-09-16 localTime = 09:59:50.002 localDateTime = 2021-09-16T09:59:50.002 ======================================= localDate1 = 2021-09-16 localDate2 = 2020-02-20 localDate3 = 2020-02-20 localDate4 = 2020-02-20 ======================================= localTime1 = 09:59:50.016 localTime2 = 07:30 localTime3 = 07:30 localTime4 = 07:29:59.999000123 ======================================= localDateTime1 = 2021-09-16T09:59:50.016 localDateTime2 = 2021-09-16T09:59:50.016 localDateTime3 = 2021-09-15T20:59:50.017 localDateTime4 = 2020-02-20T08:15:59 ======================================= zonedDateTime1 = 2020-10-31T00:00+01:00[Europe/Rome] zonedDateTime2 = 2020-10-31T13:45+01:00[Europe/Rome] zonedDateTime3 = 2021-09-16T04:20:52.591+02:00[Europe/Rome] zonedDateTime4 = 2021-09-16T10:20:52.591+08:00[Asia/Shanghai] ======================================= 这里的新API全部按照[ISO 8601](.&#x2F;日期与时间基本概念和格式介绍.md#ISO 8601)格式打印，本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，LocalDateTime、LocalDate和LocalTime默认严格按照ISO 8601规定的日期和时间格式进行打印。 JDBC对新类型的支持date -&gt; LocalDate time -&gt; LocalTime timestamp -&gt; LocalDateTime 二、LocalDate①常用的构造方法 // 常用的构造方法 LocalDate localDate1 = LocalDate.of(2020, 6, 30);//2020-06-30 LocalDate localDate2 = LocalDate.parse(&quot;2020-06-30&quot;);//2020-06-30 LocalDate localDate3_1 = LocalDate.now();//2021-09-16 LocalDate localDate3_2 = LocalDate.now(ZoneId.of(&quot;Europe/Paris&quot;));//2021-09-16 LocalDate localDate4 = LocalDate.ofYearDay(2020, 160);//2020-06-08 now()默认是获取当前系统所在的时区，也可以通过设置ZoneId来设定 除了LocalDate还有一些辅助的类YearMonth、Month、 MonthDay YearMonth yearMonth = YearMonth.now();// 2021-09 Month month = Month.from(yearMonth);// SEPTEMBER MonthDay monthDay = MonthDay.of(month, 1);// --09-01 ②常用方法先看看一个localDate对象能够给我们提供什么 // 创建LocalDate对象 LocalDate date = LocalDate.of(2020, 6, 15);//2020-06-15 // 年份 int year = date.getYear();//2020 // 月份 Month month = date.getMonth();//JUNE // 获取该月的第几天 int dayOfMoneth = date.getDayOfMonth();//15 // 获取该年的第几天 int dayOfYear = date.getDayOfYear();//167 // 获取星期几 DayOfWeek dow = date.getDayOfWeek();//MONDAY // 月份的长度 int length = date.lengthOfMonth();//30 // 是否是闰年 boolean leap = date.isLeapYear();//true // 年份 int year2 = date.get(ChronoField.YEAR);//2020 // 月份 int month2 = date.get(ChronoField.MONTH_OF_YEAR);//6 // 获取该月的第几天 int day2 = date.get(ChronoField.DAY_OF_MONTH);//15 // 获取星期几 int week2 = date.get(ChronoField.DAY_OF_WEEK);//1 // 对齐周，若周一为每月1号，这该周处于第几周 int alignWeek = date.get(ChronoField.ALIGNED_WEEK_OF_MONTH);//3 // 对齐天，若周一为每月1号，这该天是对齐周的第几天 int alignDay = date.get(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH);//1 ③计算相关 /************************* 加减计算 ****************************/ // 增加天数，date1往后增加50天 LocalDate date3 = date1.plusDays(50);//2020-08-19 // 减少天数，date1往前推10天 LocalDate date4 = date1.minusDays(10);//2020-06-20 // 增加周，date1往后增加1周 LocalDate date5 = date1.plusWeeks(1);//2020-07-07 // 增加月，date1往后增加6个月 LocalDate date6 = date1.plus(6, ChronoUnit.MONTHS);//2020-12-30 // 减少月，date1往前推2个月 LocalDate date7 = date1.minus(2, ChronoUnit.MONTHS);//2020-04-30 // 减少年，date1往前推3年 LocalDate date8 = date1.minusYears(3);//2017-06-30 // 增加年，date1往后推2年 LocalDate date9 = date1.plusYears(2);//2022-06-30 // 间隔天数，计算date3和date1相差多少天 long interval = date3.toEpochDay() - date1.toEpochDay();//50 // 间隔日期 Period between = Period.between(date1, date2);// 2月+16天 /************************* 调整和操纵 ****************************/ // 指定年份 LocalDate date20 = date1.withYear(1997);//1997-06-30 // 指定当月第几天 LocalDate date21 = date1.withDayOfMonth(25);//2020-06-25 // 指定月份 LocalDate date22 = date1.with(ChronoField.MONTH_OF_YEAR, 9);//2020-09-30 // 该月第一天 LocalDate firstDay1 = date2.withDayOfMonth(1);//2020-09-01 // 使用TemporalAdjusters工厂方法，获取该月第一天 LocalDate firstDay2 = date2.with(TemporalAdjusters.firstDayOfMonth());//2020-09-01 // 该月最后一天 LocalDate endDay = date2.with(TemporalAdjusters.lastDayOfMonth());//2020-09-30 // 该年最后一天 LocalDate endDayOfYear = date2.with(TemporalAdjusters.lastDayOfYear()); //2020-12-31 // 将日期调整为在调整日期之后指定的星期几的第一次出现 LocalDate nextSameDay = date2.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));//2020-09-20 // 取date2的第1月的第一个周一 LocalDate firstMondayOfMONDAY = date2.withMonth(1).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); // 2019-01-06 /************************* 间隔值计算 ****************************/ LocalDate localDate = LocalDate.of(2018, 1, 1); LocalDate today = LocalDate.now(); // 获取相差的天数 long betweenDays = localDate.until(today, ChronoUnit.DAYS);// 1355 // 获取相差的星期数 long betweenWeeks = localDate.until(today, ChronoUnit.WEEKS);// 193 // 获取相差的年 long betweenYears = localDate.until(today, ChronoUnit.YEARS);// 3 // 获取相差的世纪 LocalDate pass = LocalDate.of(1911, 1, 1); long betweenCenturies = pass.until(today, ChronoUnit.CENTURIES);// 1 // 获取相差的几十年 10年为1个单位 LocalDate passDecades = LocalDate.of(2000, 1, 1); long betweenDecades = passDecades.until(today, ChronoUnit.DECADES);// 2 // 获取相差的纪元 LocalDate passEras = LocalDate.of(2000, 1, 1); long betweenEras = passEras.until(today, ChronoUnit.ERAS);// 0 // 获取相差几个小时 LocalDateTime localDateTime = LocalDateTime.parse(&quot;2020-09-15T14:26:48&quot;); LocalDateTime nowDateTime = LocalDateTime.now(); long betweenHours = localDateTime.until(nowDateTime, ChronoUnit.HOURS);// 8807 关于TemporalAdjusters可以看TemporalAdjuster 匹配周期性的日期 // 计算周期性的日期，比如9·18国家纪念日 MonthDay memorialDay = MonthDay.of(9, 18); MonthDay nowDay = MonthDay.from(LocalDate.now()); // 今天是否是9月8号 boolean isNow = memorialDay.equals(nowDay); // false // 间隔几天 int betweenDay = Math.abs(memorialDay.getDayOfMonth() - nowDay.getDayOfMonth());// 1 三、LocalTimeⅠ.常用方法 /*********** 创建LocalTime **********/ LocalTime time = LocalTime.of(15, 27, 30);// 15:27:30 int hour = time.getHour();// 15 int minute = time.getMinute();// 27 int second = time.getSecond();// 30 LocalTime time1 = LocalTime.parse(&quot;16:27:30.915002654&quot;);// 16:27:30.915002654 LocalTime time2 = LocalTime.parse(&quot;16:27:30&quot;);// 16:27:30 LocalTime time3 = LocalDateTime.now().toLocalTime();// 16:40:04.408 /*********** 计算 **********/ // 增加60秒 LocalTime time4 = time.plus(60, ChronoUnit.SECONDS);// 15:28:30 // 减少10分钟 LocalTime time5 = time.plus(-10, ChronoUnit.MINUTES);// 15:17:30 // 增加3秒 LocalTime time6 = time.minus(Duration.ofSeconds(3));// 15:27:27 Ⅱ. 日期类、时间类、日期时间类通用方法通过LocalDate、LocalTime我们可以看到他们的某些API基本都有 方 法 名 是否是静态方法 方法描述 from 是 依据传入的 Temporal 对象创建对象实例 now 是 依据系统时钟创建 Temporal 对象 of 是 由 Temporal 对象的某个部分创建该对象的实例 parse 是 由字符串创建 Temporal 对象的实例 atOffset 否 将 Temporal 对象和某个时区偏移相结合 atZone 否 将 Temporal 对象和某个时区相结合 format 否 使用某个指定的格式器将Temporal 对象转换为字符串（Instant 类不提供该方法） get 否 读取 Temporal 对象的某一部分的值 minus 否 创建 Temporal 对象的一个副本，通过将当前 Temporal 对象的值减去一定的时长创建该副本 plus 否 创建 Temporal 对象的一个副本，通过将当前 Temporal 对象的值加上一定的时长创建该副本 with 否 以该 Temporal 对象为模板，对某些状态进行修改创建该对象的副本 四、LocalDateTime①常用构造/*********** 创建LocalDateTime **********/ LocalDate date = LocalDate.of(2020, 1, 1);// 2020-01-01 LocalTime time = LocalTime.of(10, 56, 30);// 10:56:30 LocalDateTime dt1 = LocalDateTime.of(2020, Month.FEBRUARY, 27, 13, 45, 20);// 2020-02-27T13:45:20 LocalDateTime dt2 = LocalDateTime.of(date, time);// 2020-01-01T10:56:30 LocalDateTime dt3 = date.atTime(9, 40, 36);// 2020-01-01T09:40:36 LocalDateTime dt4 = date.atTime(time);// 2020-01-01T10:56:30 LocalDateTime dt5 = time.atDate(date);// 2020-01-01T10:56:30 LocalDateTime dt6 = LocalDateTime.parse(&quot;2020-10-01T10:01:59&quot;);// 2020-10-01T10:01:59 ②计算操纵/*********** 计算LocalDateTime **********/ LocalDateTime now = LocalDateTime.now();// 2021-09-17T17:14:59.601 // 增加指定值 LocalDateTime dateTime = now.plusYears(1) .plusMonths(2L) .plusWeeks(4) .plusDays(10) .plusHours(18) .plusMinutes(12) .plusSeconds(1) .plusNanos(600000L); // 2022-12-26T11:27:00.601600 // 增加半天 LocalDateTime dateTime1 = now.plus(1, ChronoUnit.HALF_DAYS);// 2021-09-18T05:14:59.601 // 增加2天 LocalDateTime dateTime2 = now.plus(2, ChronoUnit.DAYS);// 2021-09-19T17:14:59.601 // 世纪 LocalDateTime dateTime3 = now.plus(1, ChronoUnit.CENTURIES);// 2121-09-17T17:14:59.601 // 增加二十年 LocalDateTime dateTime4 = now.plus(2, ChronoUnit.DECADES);// 2041-09-17T17:14:59.601 // 减少1千年 LocalDateTime dateTime5 = now.minus(1, ChronoUnit.MILLENNIA);// 1021-09-17T17:14:59.601 // 永恒，执行不成功 LocalDateTime dateTime6 = now.plus(1, ChronoUnit.FOREVER); // 微秒，执行不成功 LocalDateTime dateTime7 = now.plus(1, ChronoUnit.MICROS); // 时代，执行不成功 LocalDateTime dateTime8 = now.plus(1, ChronoUnit.ERAS); /*********** 操纵LocalDateTime **********/ LocalDateTime localDateTime = LocalDateTime.of(2020, Month.FEBRUARY, 27, 13, 45, 20);// 2020-02-27T13:45:20 LocalDateTime dateTime9 = localDateTime.withYear(2021); // 2021-02-27T13:45:20 LocalDateTime dateTime10 = localDateTime.withMonth(2); // 2020-02-27T13:45:20 LocalDateTime dateTime11 = localDateTime.withDayOfMonth(1); // 2020-02-01T13:45:20 LocalDateTime dateTime12 = localDateTime.with(TemporalAdjusters.lastDayOfMonth());// 2020-02-29T13:45:20 LocalDateTime dateTime13 = localDateTime.with(TemporalAdjusters.firstDayOfMonth());// 2020-02-01T13:45:20 // 设置为当前所处时间的周一 LocalDateTime dateTime14 = localDateTime.with(ChronoField.DAY_OF_WEEK, 1);// 2020-02-24T13:45:20 // 日期设置月为3，并且设置为当月的第一个周二 LocalDateTime dateTime15 = localDateTime.with(ChronoField.MONTH_OF_YEAR, 3) .with(TemporalAdjusters.firstInMonth(DayOfWeek.TUESDAY));// 2020-03-03T13:45:20 ③时间操作API 序号 函数 返回 描述 1 plus LocalDateTime 加上指定数量的时间得到的值 2 plusDays LocalDateTime 加上指定天数得到的值 3 plusHours LocalDateTime 加上指定小时数得到的值 4 plusMinutes LocalDateTime 加上指定分钟数得到的值 5 plusMonths LocalDateTime 加上指定月数得到的值 6 plusNanos LocalDateTime 加上指定纳秒数得到的值 7 plusSeconds LocalDateTime 加上指定秒数得到的值 8 plusWeeks LocalDateTime 加上指定星期数得到的值 9 plusYears LocalDateTime 加上指定年数得到的值 10 with LocalDateTime 指定字段更改为新值后的拷贝 11 withDayOfMonth LocalDateTime 月的第几天更改为新值后的拷贝 12 withDayOfYear LocalDateTime 年的第几天更改为新值后的拷贝 13 withHour LocalDateTime 小时数更改为新值后的拷贝 14 withMinute LocalDateTime 分钟数更改为新值后的拷贝 15 withMonth LocalDateTime 月份更改为新值后的拷贝 16 withNano LocalDateTime 纳秒数更改为新值后的拷贝 17 withSecond LocalDateTime 秒数更改为新值后的拷贝 18 withYear LocalDateTime 年份更改为新值后的拷贝 ④获取时间属性值API 序号 函数 描述 1 get 得到LocalDateTime的指定字段的值 2 getDayOfMonth 得到LocalDateTime是月的第几天 3 getDayOfWeek 得到LocalDateTime是星期几 4 getDayOfYear 得到LocalDateTime是年的第几天 5 getHour 得到LocalDateTime的小时 6 getLong 得到LocalDateTime指定字段的值 7 getMinute 得到LocalDateTime的分钟 8 getMonth 得到LocalDateTime的月份，获取的结果是月份的枚举值 9 getMonthValue 得到LocalDateTime的月份，从1到12 10 getNano 得到LocalDateTime的纳秒数 11 getSecond 得到LocalDateTime的秒数 12 getYear 得到LocalDateTime的年份 ⑤其他API 序号 函数 描述 类别 1 atOffset 结合LocalDateTime和ZoneOffset创建一个OffsetDateTime 时区相关 2 atZone 结合LocalDateTime和指定时区创建一个ZonedDateTime 时区相关 3 ofEpochSecond 根据秒数(从1970-01-0100:00:00开始)创建LocalDateTime 实例方法 4 ofInstant 根据Instant和ZoneId创建LocalDateTime 实例方法 5 compareTo 比较两个LocalDateTime，小于返回-1，等于返回0，大于返回1 比较方法 6 isAfter 判断LocalDateTime是否在指定LocalDateTime之后 比较方法 7 isBefore 判断LocalDateTime是否在指定LocalDateTime之前 比较方法 8 isEqual 判断两个LocalDateTime是否相等 比较方法 9 format 格式化LocalDateTime生成一个字符串 格式化方法 10 from 转换TemporalAccessor为LocalDateTime 格式化方法 11 parse 解析字符串得到LocalDateTime 格式化方法 12 isSupported 判断LocalDateTime是否支持指定时间字段或单元 其他 13 toString 返回LocalDateTime的字符串表示 其他 14 range 返回指定时间字段的数值范围范围（ChronoField） 其他 15 truncatedTo 返回LocalDateTime截取到指定时间单位的拷贝，如果无法截断抛DateTimeException，如果不支持截断单位抛UnsupportedTemporalTypeException 其他 16 until 计算LocalDateTime和另一个LocalDateTime之间的时间差，可以指定时间单位（ChronoUnit） 其他 17 adjustInto 将目标对象调整为指定的时间对象，指定对象调用方法，目标对象作为参数 其他 18 query 使用指定的查询查询此日期时间，查询LocalDateTime（TemporalQueries） 其他 五、TemporalAdjuster①TemporalAdjusters工厂类中的方法 方 法 名 方法描述 dayOfWeekInMonth 创建一个新的日期，它的值为同一个月中每一周的第几天 firstDayOfMonth 创建一个新的日期，它的值为当月的第一天 firstDayOfNextMonth 创建一个新的日期，它的值为下月的第一天 firstDayOfNextYear 创建一个新的日期，它的值为明年的第一天 firstDayOfYear 创建一个新的日期，它的值为当年的第一天 firstInMonth 创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的值 lastDayOfMonth 创建一个新的日期，它的值为当月的最后一天 lastDayOfNextMonth 创建一个新的日期，它的值为下月的最后一天 lastDayOfNextYear 创建一个新的日期，它的值为明年的最后一天 lastDayOfYear 创建一个新的日期，它的值为今年的最后一天 lastInMonth 创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的值 next&#x2F;previous 创建一个新的日期，并将其值设定为日期调整后或者调整前，第一个符合指定星期几要求的日期 nextOrSame&#x2F;previousOrSame 创建一个新的日期，并将其值设定为日期调整后或者调整前，第一个符合指定星期几要求的日期，如果该日期已经符合要求，直接返回该对象 ②TemporalAdjuster接口 LocalDate localDate1 = LocalDate.of(2020, 10, 1); LocalDate localDate2 = localDate1.with(temporal -&gt; &#123; // 获取星期几 DayOfWeek week = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK)); int dayToAdd = 1; if (DayOfWeek.FRIDAY.equals(week)) dayToAdd = 3; else if (DayOfWeek.SATURDAY.equals(week)) dayToAdd = 2; // 周五和周六分别加3天和2天，其余加1天 return temporal.plus(dayToAdd, ChronoUnit.DAYS); &#125;); System.out.println(localDate2);// 2020-10-02 六、DateTimeFormatterⅠ.一般用法LocalDate date = LocalDate.of(2020, 10, 1); LocalDateTime dateTime = LocalDateTime.now(); ZonedDateTime zonedDateTime = ZonedDateTime.now(); // 自带的格式化器 String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE);// 20201001 String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE);// 2020-10-01 // 解析字符串 LocalDate date1 = LocalDate.parse(&quot;20200918&quot;, DateTimeFormatter.BASIC_ISO_DATE);// 2020-09-18 LocalDate date2 = LocalDate.parse(&quot;2018-01-15&quot;, DateTimeFormatter.ISO_LOCAL_DATE);// 2018-01-15 // 自定义格式化器 DateTimeFormatter timeFormatter1 = DateTimeFormatter.ofPattern(&quot;d. MMMM yyyy&quot;, Locale.CHINA); DateTimeFormatter timeFormatter2 = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;); DateTimeFormatter timeFormatter3 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); DateTimeFormatter timeFormatter4 = DateTimeFormatter.ofPattern(&quot;MM月dd日&quot;); DateTimeFormatter timeFormatter5 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&#39;T&#39;HH:mm ZZZZ&quot;); DateTimeFormatter zhFormatter = DateTimeFormatter.ofPattern(&quot;yyyy MMM dd EE HH:mm&quot;, Locale.CHINA); DateTimeFormatter usFormatter = DateTimeFormatter.ofPattern(&quot;E, MMMM/dd/yyyy HH:mm&quot;, Locale.US); String s3 = date.format(timeFormatter1);// 1. 十月 2020 String s4 = date.format(timeFormatter2);// 2020年10月01日 //String s5 = date.format(timeFormatter3);// 报错，没有时间可以格式化 String s6 = dateTime.format(timeFormatter3);// 2021-09-17 17:44:17 String s7 = date.format(timeFormatter4);// 10月01日 LocalDate date4 = LocalDate.parse(s3, timeFormatter1);//2018-10-31 //LocalDate date5 = LocalDate.parse(s7, timeFormatter4);// 报错，缺少年 String s8 = zonedDateTime.format(usFormatter);// Fri, September/17/2021 17:48 String s9 = zonedDateTime.format(zhFormatter);// 2021 九月 17 星期五 17:48 String s10 = zonedDateTime.format(timeFormatter5);// 2021-09-17T17:48 GMT+08:00 Ⅱ.自定义 ZonedDateTime zonedDateTime = ZonedDateTime.now(); DateTimeFormatter italianFormatter = new DateTimeFormatterBuilder() .appendText(ChronoField.DAY_OF_MONTH) .appendLiteral(&quot;-&quot;) .appendText(ChronoField.MONTH_OF_YEAR) .appendLiteral(&quot;-&quot;) .appendText(ChronoField.YEAR) .appendLiteral(&quot;-&quot;) .appendZoneRegionId() .parseCaseInsensitive() .toFormatter(Locale.CHINA); String format = zonedDateTime.format(italianFormatter);//17-九月-2021-Asia/Shanghai LocalDate parse = LocalDate.parse(format, italianFormatter);//2021-09-17 七、ZoneId、ZoneOffset、ZonedDateTime ①时间戳： 是指格林威治（地球零时区）时间1970年01月01日00时00分00秒起至现在的总秒数，这个时间戳，在地球的各个地方都是一致的; ②时区：由于地球的自转，根据接收太阳光照的顺序将地球划分成24个区，从而方便当地人的生产生活，每个时区相差一小时，可以根据时间戳和时区计算当地的时间。格林威治处于零时区，北京处于东八区，因此，北京时间比格林威治时间早8个小时 ③UTC时间：就是零时区的时间，它的全称是Coordinated Universal Time ，即世界协调时间。另一个常见的缩写是GMT，即格林威治标准时间，格林威治位于 零时区，因此，我们平时说的UTC时间和GMT时间在数值上面都是一样的 类java.time.ZoneId是原有的java.util.TimeZone类的替代品 ①ZoneId1. 获取时区 // 获取默认时区 ZoneId systemZoneId = ZoneId.systemDefault(); // 获取上海时区 ZoneId shanghaiZoneId = ZoneId.of(&quot;Asia/Shanghai&quot;); // 获取巴黎时区 ZoneId parisZoneId = ZoneId.of(&quot;Europe/Paris&quot;); // 获取所有合法的“区域/城市”字符串 Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds(); 2. 和TimeZone的转换 // 转换 ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId(); 3. 时区结合其他日期时间api// 时区结合其他日期时间api ZonedDateTime zonedDateTime = ZonedDateTime.of(LocalDateTime.now(parisZoneId), shanghaiZoneId); // 打印：2021-09-17T04:58:36.247+08:00[Asia/Shanghai] ②ZoneOffset首先我们要明确北京时间比UTC快8个小时，所以应该是GMT+8:00 格林威治标准时间（GMT） 地区：英国 皇家格林尼治天文台 时区：UTC&#x2F;GMT 0 (零时区) 北京时差：现在格林威治时间比北京时间晚8小时 ZoneOffset表示与格林威治&#x2F; UTC的时区偏移量；以当前时间和世界标准时间（UTC）&#x2F;格林威治时间（GMT）的偏差来计算日期时间 // 偏移 ZoneOffset beijing = ZoneOffset.of(&quot;+08:00&quot;);// +08:00 ZoneOffset utc = ZoneOffset.of(&quot;+00:00&quot;);// Z // 获取UTC时间 LocalDateTime utcTime = LocalDateTime.now(ZoneOffset.UTC);// 2021-09-17T03:30:05.972 // 获取带时区和偏移的时间 OffsetDateTime offsetDateTime = OffsetDateTime.of(utcTime, utc);// 2021-09-17T03:30:05.972Z // 获取带时区的时间 ZonedDateTime utcDateTime = offsetDateTime.toZonedDateTime();// 2021-09-17T03:30:05.972Z // 转为本地时区的时间 ZonedDateTime localDateTime = utcDateTime.withZoneSameInstant(ZoneId.of(&quot;Asia/Shanghai&quot;)); // 2021-09-17T11:30:05.972+08:00[Asia/Shanghai] ③ZonedDateTimeZonedDateTime对象由两部分构成，LocalDateTime和ZoneId，其中2021-09-17T04:58:36.247部分为LocalDateTime，+08:00[Asia/Shanghai]部分为ZoneId。 所以，总的来说： ZonedDateTime是带时区的日期和时间，可用于时区转换； ZonedDateTime和LocalDateTime可以相互转换。 1. 创建方法LocalDateTime ldt = LocalDateTime.of(2020, 9, 15, 10, 30, 17);// 2020-09-15T10:30:17 ZonedDateTime zonedDateTime1 = ldt.atZone(ZoneId.systemDefault());// 2020-09-15T10:30:17+08:00[Asia/Shanghai] ZonedDateTime zonedDateTime2 = ldt.atZone(ZoneId.of(&quot;America/New_York&quot;));// 2020-09-15T10:30:17-04:00[America/New_York] 2. 转换方法// 以中国时区获取当前时间: ZonedDateTime shangHai = ZonedDateTime.now(ZoneId.of(&quot;Asia/Shanghai&quot;));// 2021-09-17T11:46:26.960+08:00[Asia/Shanghai] // 转换为纽约时间: ZonedDateTime newYork = shangHai.withZoneSameInstant(ZoneId.of(&quot;America/New_York&quot;));// 2021-09-16T23:46:26.960-04:00[America/New_York] 转换为LocalDateTime时，直接丢弃了时区信息。 LocalDateTime shangHaiDateTime = shangHai.toLocalDateTime();// 2021-09-17T11:48:26.050 LocalDateTime newYorkDateTime = newYork.toLocalDateTime();// 2021-09-16T23:48:26.050 3. 计算航班时间某航线从北京飞到纽约需要13小时15分钟，请根据北京起飞日期和时间计算到达纽约的当地日期和时间 // 起飞时间 LocalDateTime departure = LocalDateTime.parse(&quot;2020-09-15T18:30:58&quot;); int hours = 13; int minutes = 15; ZonedDateTime departureZoned = ZonedDateTime.of(departure,ZoneId.of(&quot;Asia/Shanghai&quot;)); // 通过ZonedDateTime计算并转换时区 ZonedDateTime arrivalZoned = departureZoned.plusHours(hours).plusMinutes(minutes).withZoneSameInstant(ZoneId.of(&quot;America/New_York&quot;)); LocalDateTime arrival = arrivalZoned.toLocalDateTime(); System.out.println(departure + &quot; -&gt; &quot; + arrival); // 2020-09-15T18:30:58 -&gt; 2020-09-15T19:45:58 八、InstantInstant是时间线上的一个点，表示一个时间戳。Instant可以精确到纳秒，这超过了long的最大表示范围，所以在Instant的实现中是分成了两部分来表示，一部分是seconds，表示从1970-01-01 00:00:00开始到现在的秒数，另一个部分是nanos，表示纳秒部分。以下是创建Instant的两种方法： Instant now = Instant.now(); //获取当前时刻的时间戳，结果为：2020-04-02T07:30:23.811Z; Instant instant = Instant.ofEpochSecond(600, 1000000); //ofEpochSecond()方法的第一个参数为秒，第二个参数为纳秒，上面的代码表示从1970-01-01 00:00:00开始后一分钟的10万纳秒的时刻， //其结果为：1970-01-01T00:10:00.001Z。 九、Period和Duration Period : 用于计算两个日期（年月日）间隔。 Duration : 用于计算两个时间（秒，纳秒）间隔。 Duration minutes1 = Duration.ofMinutes(2);// 2分钟间隔 Duration minutes2 = Duration.of(6, ChronoUnit.MINUTES); // 6分钟间隔 Period days = Period.ofDays(20); Period weeks = Period.ofWeeks(5); Period period = Period.of(1, 2, 3); //1年2月3天 P1Y2M3D ①Period参与计算结合plus()和minus()进行日期的加减 LocalDate localDate = LocalDate.parse(&quot;2020-05-10&quot;); LocalDate date1 = localDate.plus(Period.ofDays(5));// 2020-05-15 LocalDate date2 = localDate.plus(Period.ofMonths(2));// 2020-07-10 ②计算间隔值，差值 LocalDate localDate = LocalDate.parse(&quot;2020-05-10&quot;); LocalDate today = LocalDate.now(); Period period = Period.between(localDate, today);// 1年4月7天 // 相差天数 long between1 = ChronoUnit.DAYS.between(localDate, today);// 495 // 相差月份 long between2 = ChronoUnit.MONTHS.between(localDate, today);// 16 ③Duration LocalTime startTime = LocalTime.of(6, 30, 0); LocalTime endTime = startTime.plusSeconds(120); LocalTime endTime2 = startTime.plusNanos(6 * 1000000000L); long betweenSec1 = Duration.between(startTime, endTime).getSeconds();// 120 long betweenSec2 = ChronoUnit.SECONDS.between(startTime, endTime);// 120 long betweenSec3 = Duration.between(startTime, endTime2).getSeconds();// 6 ④Duration中的API 方 法 名 是否是静态方法 方法描述 between 是 创建两个时间点之间的 interval from 是 由一个临时时间点创建 interval of 是 由它的组成部分创建 interval 的实例 parse 是 由字符串创建 interval 的实例 addTo 否 创建该 interval 的副本，并将其叠加到某个指定的 temporal 对象 get 否 读取该 interval 的状态 isNegative 否 检查该 interval 是否为负值，不包含零 isZero 否 检查该 interval 的时长是否为零 minus 否 通过减去一定的时间创建该 interval 的副本 multipliedBy 否 将 interval 的值乘以某个标量创建该 interval 的副本 negated 否 以忽略某个时长的方式创建该 interval 的副本 plus 否 以增加某个指定的时长的方式创建该 interval 的副本 subtractFrom 否 从指定的 temporal 对象中减去该 interval 十、新API和Date、Calendar的相互转换LocalDateTime 与 Date 的相互转化由于 LocalDate、LocalTime 或者只含有日期，或者只含有时间，因此，不能和Date直接进行转化。 // Date 转化成 LocalDateTime public static LocalDateTime dateToLocalDate(Date date) &#123; Instant instant = date.toInstant(); ZoneId zoneId = ZoneId.systemDefault(); return instant.atZone(zoneId).toLocalDateTime(); &#125; // LocalDateTime 转化成 Date public static Date localDateTimeToDate(LocalDateTime localDateTime) &#123; ZoneId zoneId = ZoneId.systemDefault(); ZonedDateTime zdt = localDateTime.atZone(zoneId); return Date.from(zdt.toInstant()); &#125; 基本都是先转换成Instant，然后在进行互转 LocalDateTime localDateTime1 = LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault());// 2021-09-17T15:51:14.842 LocalDateTime localDateTime2 = LocalDateTime.ofInstant(Calendar.getInstance().toInstant(), ZoneId.systemDefault());// 2021-09-17T15:51:14.845 // epochSecond - 从1970-01-01T00：00：00Z的时代开始的秒数 ； nanoOfSecond - 秒内的纳秒，从0到999,999,999；offset - 区域偏移，不为空 LocalDateTime localDateTime3 = LocalDateTime.ofEpochSecond(LocalDateTime.now().toEpochSecond(ZoneOffset.of(&quot;+08:00&quot;)), 0, ZoneOffset.UTC);// 2021-09-17T07:51:16 (取UTC实际应该是这个值) LocalDateTime localDateTime4 = LocalDateTime.ofEpochSecond(LocalDateTime.now().toEpochSecond(ZoneOffset.UTC), 0, ZoneOffset.UTC);// 2021-09-17T15:51:16 十一、旧项目JDK8之前的版本替换方案Threeten对于从Java 7或Java 6这些老项目来说可以使用Threeten ,然后可以像在上面java 8一样使用相同的功能，一旦你迁移到java 8 只需要修改你的包路径代码而无需变更： &lt;dependency&gt; &lt;groupId&gt;org.threeten&lt;/groupId&gt; &lt;artifactId&gt;threetenbp&lt;/artifactId&gt; &lt;version&gt;LATEST&lt;/version&gt; &lt;/dependency&gt; Joda-TimeJava 8 日期和时间库的另一种替代方案是Joda-Time库。事实上，Java 8 Date Time API由Joda-Time库（Stephen Colebourne）和Oracle共同领导。该库提供了Java 8 Date Time项目中支持的几乎所有功能。通过在项目中引用以下pom依赖项就可以立即使用： &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;LATEST&lt;/version&gt; &lt;/dependency&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/categories/Java/"},{"name":"java.time包","slug":"Java/java-time包","permalink":"https://xucux.github.io/categories/Java/java-time%E5%8C%85/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/tags/Java/"},{"name":"LocalDateTime","slug":"LocalDateTime","permalink":"https://xucux.github.io/tags/LocalDateTime/"}],"author":"xucux"},{"title":"SpringBoot集成企业微信群机器人（运维报警）","slug":"SpringBoot集成企业微信群机器人（运维报警）","date":"2023-01-29T09:40:50.000Z","updated":"2023-02-02T09:56:25.476Z","comments":true,"path":"post/SpringBoot集成企业微信群机器人（运维报警）/","link":"","permalink":"https://xucux.github.io/post/SpringBoot%E9%9B%86%E6%88%90%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88%E8%BF%90%E7%BB%B4%E6%8A%A5%E8%AD%A6%EF%BC%89/","excerpt":"之前有集成过钉钉群机器人🤖报警，这次主要是SpringBoot集成企业微信群机器人报警，主要使用两种方式调用企业微信的HttpApi，一种为Forest，一种为RestTemplate","text":"之前有集成过钉钉群机器人🤖报警，这次主要是SpringBoot集成企业微信群机器人报警，主要使用两种方式调用企业微信的HttpApi，一种为Forest，一种为RestTemplate 相关文档： 企业微信群机器人配置说明 1.配置参数import lombok.Getter; import lombok.Setter; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import java.util.List; /** * @descriptions: 配置参数 * @author: xucux */ @Component @Getter @Setter @ConfigurationProperties(prefix = &quot;notice&quot;) public class NoticeProperties &#123; private String wechatKey; private List&lt;String&gt; phoneList; &#125; 这个key的获取方式：群机器人配置说明 yaml文件配置数据： notice: ####### 企业微信群机器人key wechat-key: xxxxxxxxx-xxx-xxx-xxxx-xxxxxxxxxx ####### 需要@的群成员手机号 phone-list: 2.Forest的Http客户端配置使用Forest这里用的Forest ，感觉还挺强大灵活 官方文档，如果你喜欢使用httpClient或者okHttp建议你看看forest ；如果你更喜欢RestTemplate，那就使用RestTemplate。 POM依赖&lt;!-- 轻量级HTTP客户端框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.dtflys.forest&lt;/groupId&gt; &lt;artifactId&gt;forest-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.28&lt;/version&gt; &lt;/dependency&gt; yaml文件配置日志打开关闭请参考自己的业务需要 ## 轻量级HTTP客户端框架forest forest: # 配置底层API为 okhttp3 backend: okhttp3 # 连接池最大连接数，默认值为500 max-connections: 1000 # 每个路由的最大连接数，默认值为500 max-route-connections: 500 # 请求超时时间，单位为毫秒, 默认值为3000 timeout: 3000 # 连接超时时间，单位为毫秒, 默认值为2000 connect-timeout: 3000 # 请求失败后重试次数，默认为0次不重试 retry-count: 1 # 单向验证的HTTPS的默认SSL协议，默认为SSLv3 ssl-protocol: SSLv3 # 打开或关闭日志，默认为true logEnabled: true # 打开/关闭Forest请求日志（默认为 true） log-request: true # 打开/关闭Forest响应状态日志（默认为 true） log-response-status: true # 打开/关闭Forest响应内容日志（默认为 false） log-response-content: true 发送请求public interface NoticeClient &#123; /** * 企业微信机器人 发送 https 请求 * * @param keyValue * @return */ @Post( url = &quot;https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=&#123;keyValue&#125;&quot;, headers = &#123; &quot;Accept-Charset: utf-8&quot;, &quot;Content-Type: application/json&quot; &#125;, dataType = &quot;json&quot; ) ForestResponse&lt;JsonObject&gt; weChatNotice(@Var(&quot;keyValue&quot;) String keyValue, @JSONBody Map&lt;String, Object&gt; body ); &#125; 3.定义服务3.1 接口/** * @descriptions: 消息通知接口 * @author: xucux */ public interface NoticeService &#123; /** * 发送错误信息至群机器人 * @param throwable * @param msg */ void sendError(Throwable throwable,String msg); /** * 发送文本信息至群机器人 * @param msg */ void sendByMd(String msg); /** * 发送md至群机器人 * @param msg 文本消息 * @param isAtALL 是否@所有人 true是 false否 */ void sendByText(String msg,boolean isAtALL); &#125; 3.2 服务实现注意：这里的包名（com.github）填自己项目内的包名 import com.dtflys.forest.http.ForestResponse; import com.google.gson.JsonObject; import lombok.extern.slf4j.Slf4j; import org.apache.commons.collections4.CollectionUtils; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Service; import java.io.ByteArrayOutputStream; import java.io.PrintStream; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.stream.Collectors; /** * @descriptions: 通知实现 * @author: xucux */ @Service @Slf4j public class NoticeServiceImpl implements NoticeService &#123; @Value(&quot;$&#123;spring.application.name&#125;&quot;) private String appName; @Value(&quot;$&#123;spring.profiles.active&#125;&quot;) private String env; @Autowired private NoticeClient noticeClient; @Autowired private NoticeProperties noticeProperties; /** * 发送错误信息至群机器人 * * @param throwable * @param msg */ @Override public void sendError(Throwable throwable, String msg) &#123; String errorClassName = throwable.getClass().getSimpleName(); if (StringUtils.isBlank(msg))&#123; msg = throwable.getMessage() == null ? &quot;出现null值&quot; : throwable.getMessage(); &#125; ByteArrayOutputStream baos = new ByteArrayOutputStream(); throwable.printStackTrace(new PrintStream(baos)); String bodyStr = StringComUtils.limitStrNone(regexThrowableStr(baos.toString()),450); String md = getMdByTemplate(appName, env, errorClassName, msg, bodyStr); sendByMd(md); &#125; /** * 发送文本信息至群机器人 * * @param msg */ @Override public void sendByMd(String msg) &#123; try &#123; Map&lt;String, Object&gt; params = buildMdParams(msg); ForestResponse&lt;JsonObject&gt; response = noticeClient.weChatNotice(noticeProperties.getWechatKey(), params); log.debug(&quot;WeChatRobo-Send Error:&#123;&#125; Status:&#123;&#125;&quot;,response.isError(),response.getStatusCode()); &#125; catch (Exception e) &#123; log.error(&quot;WeChatRobot-发送文本消息异常 body:&#123;&#125;&quot;,msg,e); &#125; &#125; /** * 发送md至群机器人 * * @param msg */ @Override public void sendByText(String msg,boolean isAtALL) &#123; try &#123; Map&lt;String, Object&gt; params = buildTextParams(msg,noticeProperties.getPhoneList(),isAtALL); ForestResponse&lt;JsonObject&gt; response = noticeClient.weChatNotice(noticeProperties.getWechatKey(), params); log.debug(&quot;WeChatRobo-Send Error:&#123;&#125; Status:&#123;&#125;&quot;,response.isError(),response.getStatusCode()); &#125; catch (Exception e) &#123; log.error(&quot;WeChatRobot-发送文本消息异常 body:&#123;&#125;&quot;,msg,e); &#125; &#125; /** * 构建发送文本消息格式的参数 * @param phoneList @群用户 * @param isAtALL 是否@所有人 * @return */ private Map&lt;String,Object&gt; buildTextParams(String text, List&lt;String&gt; phoneList, boolean isAtALL)&#123; Map&lt;String,Object&gt; params = new HashMap&lt;&gt;(); Map&lt;String,Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;content&quot;,text); if (isAtALL)&#123; phoneList.add(&quot;@all&quot;); &#125; if (CollectionUtils.isNotEmpty(phoneList))&#123; data.put(&quot;mentioned_mobile_list&quot;, phoneList); &#125; params.put(&quot;msgtype&quot;,&quot;text&quot;); params.put(&quot;text&quot;,data); return params; &#125; /** * 构建发送markdown消息格式的参数 * * @param md * @return */ private Map&lt;String,Object&gt; buildMdParams(String md)&#123; Map&lt;String,Object&gt; params = new HashMap&lt;&gt;(); Map&lt;String,Object&gt; data = new HashMap&lt;&gt;(); data.put(&quot;content&quot;,md); params.put(&quot;msgtype&quot;,&quot;markdown&quot;); params.put(&quot;markdown&quot;,data); return params; &#125; private String regexThrowableStr(String str)&#123; try &#123; // 注意：这里的包名（com.github）填自己项目内的包名 String pattern = &quot;(com)(\\\\.)(github)(.&#123;10,200&#125;)(\\\\))&quot;; Pattern r = Pattern.compile(pattern); Matcher m=r.matcher(str); List&lt;String&gt; list = new ArrayList&lt;&gt;(); while (m.find()) &#123; list.add(m.group()); &#125; if (CollectionUtils.isEmpty(list))&#123; return str; &#125; String s = list.stream().collect(Collectors.joining(&quot;\\n&quot;)); return s; &#125; catch (Exception e) &#123; return str; &#125; &#125; private String getMdByTemplate(String appName,String env,String errorClassName,String msg,String bodyStr)&#123; String titleTpl = &quot;### 异常告警通知\\n#### 应用：%s\\n#### 环境：&lt;font color=\\&quot;info\\&quot;&gt;%s&lt;/font&gt;\\n##### 异常：&lt;font color=\\&quot;warning\\&quot;&gt;%s&lt;/font&gt;\\n&quot;; String bodyTpl = &quot;\\nMsg：%s\\nDetail：\\n&gt;%s&quot;; String footerTpl = &quot;\\n&lt;font color=\\&quot;comment\\&quot;&gt;%s&lt;/font&gt;&quot;; String title = String.format(titleTpl, appName, env, errorClassName); String body = String.format(bodyTpl, msg,bodyStr); String dateStr = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH:mm:ss&quot;)); String footer = String.format(footerTpl, dateStr); return title.concat(body).concat(footer); &#125; &#125; 使用到的工具方法： /** * 限制文本描述 * * @param content 内容或问题 * @param charNumber 长度 * @return */ public static String limitStrNone(String content ,int charNumber)&#123; if (StringUtils.isNotBlank(content))&#123; if (content.length() &gt; charNumber)&#123; String substring = content.substring(0, charNumber); return substring; &#125;else &#123; return content; &#125; &#125; return &quot;&quot;; &#125; 4.群接收消息的效果 5.使用RestTemplate发送请求时配置RestTemplateimport org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.http.client.ClientHttpRequestFactory; import org.springframework.http.client.SimpleClientHttpRequestFactory; import org.springframework.web.client.RestTemplate; import java.util.Collections; /** * @descriptions: RestTemplate配置 * @author: xucux */ @Configuration public class RestTemplateConfig &#123; @Bean public RestTemplate restTemplate(ClientHttpRequestFactory factory,)&#123; RestTemplate restTemplate = new RestTemplate(factory); //restTemplate.setInterceptors(Collections.singletonList(restLogInterceptor)); // 这里可以注入自定义拦截器 return restTemplate; &#125; @Bean public ClientHttpRequestFactory simpleClientHttpRequestFactory()&#123; SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory(); // 单位为ms factory.setReadTimeout(10000); // 单位为ms factory.setConnectTimeout(10000); return factory; &#125; &#125; 重新在写一个NoticeClient，其中还有一个方法是介绍RestTemplate如何发送文件 import com.alibaba.fastjson.JSONObject; import com.sztb.component.exception.BaseAssert; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.io.InputStreamResource; import org.springframework.core.io.Resource; import org.springframework.http.HttpEntity; import org.springframework.http.HttpHeaders; import org.springframework.http.MediaType; import org.springframework.http.ResponseEntity; import org.springframework.util.LinkedMultiValueMap; import org.springframework.util.MultiValueMap; import org.springframework.web.client.RestTemplate; import java.io.IOException; import java.io.InputStream; import java.util.Map; /** * @descriptions: 发送给企业微信机器人 * @author: xucux * * https://work.weixin.qq.com/api/doc/90000/90136/91770 */ public class NoticeClient &#123; @Autowired private RestTemplate restTemplate; public static final String SEND_MESSAGE_URL = &quot;https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=&#123;weChatKey&#125;&quot;; public static final String UPLOAD_FILE_URL = &quot;https://qyapi.weixin.qq.com/cgi-bin/webhook/upload_media?key=&#123;weChatKey&#125;&amp;type=file&quot;; public ResponseEntity&lt;JSONObject&gt; weChatNotice(String weChatKey, Map&lt;String, Object&gt; body )&#123; BaseAssert.verify(StringUtils.isBlank(weChatKey),&quot;消息推送给机器人失败，未配置：weChatKey&quot;); ResponseEntity&lt;JSONObject&gt; response = restTemplate.postForEntity(SEND_MESSAGE_URL, body, JSONObject.class,weChatKey); return response; &#125; public ResponseEntity&lt;JSONObject&gt; uploadMedia(String weChatKey, String fileName, InputStream inputStream)&#123; BaseAssert.verify(StringUtils.isAnyBlank(weChatKey,fileName),&quot;文件推送企业微信失败，未配置：weChatKey，fileName&quot;); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.MULTIPART_FORM_DATA); MultiValueMap&lt;String, Object&gt; body = new LinkedMultiValueMap&lt;&gt;(); // 新建流资源，必须重写contentLength()和getFilename() Resource resource = new InputStreamResource(inputStream)&#123; //文件长度,单位字节 @Override public long contentLength() throws IOException &#123; long size = inputStream.available(); return size; &#125; //文件名 @Override public String getFilename()&#123; return fileName; &#125; &#125;; body.add(&quot;media&quot;,resource); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity(body, headers); ResponseEntity&lt;JSONObject&gt; response = restTemplate.postForEntity(UPLOAD_FILE_URL, entity, JSONObject.class,weChatKey); return response; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/tags/Java/"},{"name":"企业微信","slug":"企业微信","permalink":"https://xucux.github.io/tags/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xucux.github.io/tags/SpringBoot/"},{"name":"报警","slug":"报警","permalink":"https://xucux.github.io/tags/%E6%8A%A5%E8%AD%A6/"}],"author":"xucux"},{"title":"Maven的setting配置属性解析","slug":"Maven的setting配置属性解析","date":"2023-01-29T09:33:05.000Z","updated":"2023-02-02T09:56:25.476Z","comments":true,"path":"post/Maven的setting配置属性解析/","link":"","permalink":"https://xucux.github.io/post/Maven%E7%9A%84setting%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90/","excerpt":"Maven的setting.xml文件解析","text":"Maven的setting.xml文件解析 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;settings xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;!--本地仓库。该值表示构建系统本地仓库的路径。其默认值为$&#123;user.home&#125;/.m2/repository。 --&gt; &lt;localRepository&gt;$&#123;user.home&#125;/.m2/repository &lt;/localRepository&gt; &lt;!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。 --&gt; &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; &lt;!--Maven是否需要使用plugin-registry.xml文件来管理插件版本。 --&gt; &lt;!--如果设置为true，则在&#123;user.home&#125;/.m2下需要有一个plugin-registry.xml来对plugin的版本进行管理 --&gt; &lt;!--默认为false。 --&gt; &lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt; &lt;!--表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。 --&gt; &lt;!--当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。 --&gt; &lt;offline&gt;false&lt;/offline&gt; &lt;!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。 --&gt; &lt;!--该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。 --&gt; &lt;!--当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。 --&gt; &lt;!--默认情况下该列表包含了org.apache.maven.plugins。 --&gt; &lt;pluginGroups&gt; &lt;!--plugin的组织Id（groupId） --&gt; &lt;pluginGroup&gt;org.codehaus.mojo&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;!--用来配置不同的代理，多代理profiles可以应对笔记本或移动设备的工作环境：通过简单的设置profile id就可以很容易的更换整个代理配置。 --&gt; &lt;proxies&gt; &lt;!--代理元素包含配置代理时需要的信息 --&gt; &lt;proxy&gt; &lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt; &lt;id&gt;myproxy&lt;/id&gt; &lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt; &lt;active&gt;true&lt;/active&gt; &lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;protocol&gt;http://…&lt;/protocol&gt; &lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;host&gt;proxy.somewhere.com&lt;/host&gt; &lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; &lt;password&gt;somepassword&lt;/password&gt; &lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt; &lt;nonProxyHosts&gt;*.google.com|ibiblio.org&lt;/nonProxyHosts&gt; &lt;/proxy&gt; &lt;/proxies&gt; &lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt; &lt;servers&gt; &lt;!--服务器元素包含配置服务器时需要的信息 --&gt; &lt;server&gt; &lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt; &lt;id&gt;server001&lt;/id&gt; &lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;username&gt;my_login&lt;/username&gt; &lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;password&gt;my_password&lt;/password&gt; &lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是/home/hudson/.ssh/id_dsa）以及如果需要的话，一个密钥 --&gt; &lt;!--将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt; &lt;privateKey&gt;$&#123;usr.home&#125;/.ssh/id_dsa&lt;/privateKey&gt; &lt;!--鉴权时使用的私钥密码。 --&gt; &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt; &lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。--&gt; &lt;!--这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt; &lt;filePermissions&gt;664&lt;/filePermissions&gt; &lt;!--目录被创建时的权限。 --&gt; &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt; &lt;!--传输层额外的配置项 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/server&gt; &lt;/servers&gt; &lt;!--为仓库列表配置的下载镜像列表。 --&gt; &lt;mirrors&gt; &lt;!--给定仓库的下载镜像。 --&gt; &lt;mirror&gt; &lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt; &lt;id&gt;planetmirror.com&lt;/id&gt; &lt;!--镜像名称 --&gt; &lt;name&gt;PlanetMirror Australia&lt;/name&gt; &lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt; &lt;url&gt;http://downloads.planetmirror.com/pub/maven2&lt;/url&gt; &lt;!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo1.maven.org/maven2）的镜像，--&gt; &lt;!--就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。--&gt; &lt;!--它包含了id，activation, repositories, pluginRepositories和 properties元素。--&gt; &lt;!--这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。--&gt; &lt;!--如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 --&gt; &lt;profiles&gt; &lt;!--根据环境参数来调整的构件的配置 --&gt; &lt;profile&gt; &lt;!--该配置的唯一标识符。 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。--&gt; &lt;!--如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。--&gt; &lt;!--activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。--&gt; &lt;!--profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标识 --&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 &#39;windows&#39;) --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。--&gt; &lt;!--如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。--&gt; &lt;!--另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--对应profile的扩展属性列表。Maven属性和Ant中的属性一样，可以用来存放一些值。这些值可以在POM中的任何地方使用标记$&#123;X&#125;来使用，这里X是指属性的名称。--&gt; &lt;!--属性有五种不同的形式，并且都能在settings.xml文件中访问。 --&gt; &lt;!--1. env.X: 在一个变量前加上&quot;env.&quot;的前缀，会返回一个shell环境变量。例如,&quot;env.PATH&quot;指代了$path环境变量（在Windows上是%PATH%）。 --&gt; &lt;!--2. project.x：指代了POM中对应的元素值。 --&gt; &lt;!--3. settings.x: 指代了settings.xml中对应元素的值。 --&gt; &lt;!--4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问， --&gt; &lt;!-- 如/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0/jre。 --&gt; &lt;!--5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以$&#123;someVar&#125;的形式使用。 --&gt; &lt;properties&gt; &lt;!-- 如果这个profile被激活，那么属性$&#123;user.install&#125;就可以被访问了 --&gt; &lt;user.install&gt;usr/local/winner/jobs/maven-guide&lt;/user.install&gt; &lt;/properties&gt; &lt;!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--远程仓库唯一标识 --&gt; &lt;id&gt;codehausSnapshots&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;Codehaus Snapshots&lt;/name&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：--&gt; &lt;!--always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做:--&gt; &lt;!--ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。--&gt; &lt;!--例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt; &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。--&gt; &lt;!--Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。--&gt; &lt;!--Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。--&gt; &lt;!--每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。--&gt; &lt;!--任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。--&gt; &lt;!--如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。--&gt; &lt;!--如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;env-test&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;/settings&gt;","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xucux.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Maven","slug":"开发工具/Maven","permalink":"https://xucux.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/tags/Java/"},{"name":"工具","slug":"工具","permalink":"https://xucux.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Maven","slug":"Maven","permalink":"https://xucux.github.io/tags/Maven/"}],"author":"xucux"}],"categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://xucux.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"开发工具/Git","permalink":"https://xucux.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"},{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/categories/Java/"},{"name":"java.time包","slug":"Java/java-time包","permalink":"https://xucux.github.io/categories/Java/java-time%E5%8C%85/"},{"name":"Maven","slug":"开发工具/Maven","permalink":"https://xucux.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://xucux.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"Git","permalink":"https://xucux.github.io/tags/Git/"},{"name":"开发环境","slug":"开发环境","permalink":"https://xucux.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Java","slug":"Java","permalink":"https://xucux.github.io/tags/Java/"},{"name":"LocalDateTime","slug":"LocalDateTime","permalink":"https://xucux.github.io/tags/LocalDateTime/"},{"name":"企业微信","slug":"企业微信","permalink":"https://xucux.github.io/tags/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xucux.github.io/tags/SpringBoot/"},{"name":"报警","slug":"报警","permalink":"https://xucux.github.io/tags/%E6%8A%A5%E8%AD%A6/"},{"name":"Maven","slug":"Maven","permalink":"https://xucux.github.io/tags/Maven/"}]}